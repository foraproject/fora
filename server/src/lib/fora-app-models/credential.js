(function() {
    "use strict";

    var thunkify = require('fora-node-thunkify'),
        hasher = require('fora-app-hasher'),
        randomizer = require('fora-app-randomizer'),
        models = require('./'),
        services = require('fora-app-services'),
        DbConnector = require('fora-app-db-connector'),
        dataUtils = require('fora-data-utils');

    var emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;

    var Credential = function(params) {
        dataUtils.extend(this, params);
    };

    var credentialStore = new DbConnector(Credential);

    Credential.typeDefinition = {
        name: 'credential',
        collection: 'credential',
        schema: {
            type: 'object',
            properties: {
                email: { type: 'string' },
                emailIsVerified: { type: 'boolean' },
                preferences: {
                    type: 'object',
                    schema: {
                        properties: {
                            canEmail: { type: 'boolean' }
                        }
                    }
                },
                builtin: {
                    type: 'object',
                    schema: {
                        properties: {
                            hash: { type: 'string' },
                            salt: { type: 'string' }
                        },
                        required: [ 'hash', 'salt' ]
                    }
                },
                twitter: {
                    type: 'object',
                    schema: {
                        properties: {
                            id: { type: 'string' },
                            username: { type: 'string' },
                            accessToken: { type: 'string' },
                            accessTokenSecret: { type: 'string' }
                        },
                        required: [ 'id', 'username', 'accessToken', 'accessTokenSecret' ]
                    }
                },
                facebook: {
                    type: 'object',
                    schema: {
                        properties: {
                            id: { type: 'string' },
                            username: { type: 'string' },
                            accessToken: { type: 'string' }
                        },
                        required: [ 'id', 'username', 'accessToken' ]
                    }
                }
            }
        },
        autoGenerated: {
            createdAt: { event: 'created' },
            updatedAt: { event: 'updated' }
        },
        indexes: [
            { 'type': 1, 'email': 1 },
        ],
        links: {
            users: { type: 'user', field: 'credentialId' }
        },
        validate: function*(fields) {
            if (this.email && !emailRegex.test(this.email))
                return ['Invalid email'];
        }
    };



    /*
        Create a credential token.
        This can be used to upgrade to a user token, which is then used for login.
    */
    Credential.prototype.createSession = function*() {
        var typesService = services.get('typesService');
        var session = new models.Session(
            {
                credentialId: DbConnector.getRowId(this),
                token: randomizer.uniqueId(24)
            }
        );
        var sessionStore = new DbConnector(models.Session);
        return yield* sessionStore.save(session);
    };


    Credential.prototype.addBuiltin = function*(username, password) {
        var existing = yield* credentialStore.findOne({ "builtin.username": username });
        if (!existing) {
            var hashed = yield* thunkify(hasher)({ plaintext: password });
            this.builtin = {
                method: 'PBKDF2',
                username: username,
                salt: hashed.salt.toString('hex'),
                hash: hashed.key.toString('hex')
            };
            return yield* credentialStore.save(this);
        } else {
            throw new Error("Built-in credential with the same username already exists");
        }
    };


    Credential.prototype.addTwitter = function*(id, username, accessToken, accessTokenSecret) {
        var existing = yield* credentialStore.findOne({ "twitter.id": id });
        if (!existing) {
            this.twitter = {
                id: id,
                username: username,
                accessToken: accessToken,
                accessTokenSecret: accessTokenSecret
            };
            return yield* credentialStore.save(this);
        } else {
            throw new Error("Twitter credential with the same id already exists");
        }
    };


    Credential.authenticateBuiltin = function*(username, password) {
        var credential = yield* credentialStore.findOne({ "builtin.username": username });
        if (credential) {
            var salt = new Buffer(credential.builtin.salt, 'hex');
            result = yield* thunkify(hasher)({plaintext: password, salt: salt});
            return credential.hash === result.key.toString('hex') ?
                { token: credential.token } : { success: false, error: "Invalid username or password" };
        } else {
            return { success: false, error: "Invalid username or password" };
        }
    };


    exports.Credential = Credential;

})();
