(function() {
    "use strict";

    var _;

    var __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } };


    var thunkify = require('fora-node-thunkify'),
        ForaDbModel = require('./foramodel').ForaDbModel,
        hasher = require('fora-app-hasher'),
        randomizer = require('fora-app-randomizer'),
        models = require('./'),
        services = require('fora-app-services');


    var Credential = function() {
        ForaDbModel.apply(this, arguments);
    };

    Credential.prototype = Object.create(ForaDbModel.prototype);
    Credential.prototype.constructor = Credential;

    __extends(Credential, ForaDbModel);

    var emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;


    Credential.typeDefinition = {
        name: 'credential',
        collection: 'credential',
        schema: {
            type: 'object',
            properties: {
                email: { type: 'string' },
                emailIsVerified: { type: 'boolean' },
                preferences: {
                    type: 'object',
                    schema: {
                        properties: {
                            canEmail: { type: 'boolean' }
                        }
                    }
                },
                builtin: {
                    type: 'object',
                    schema: {
                        properties: {
                            hash: { type: 'string' },
                            salt: { type: 'string' }
                        },
                        required: [ 'hash', 'salt' ]
                    }
                },
                twitter: {
                    type: 'object',
                    schema: {
                        properties: {
                            id: { type: 'string' },
                            username: { type: 'string' },
                            accessToken: { type: 'string' },
                            accessTokenSecret: { type: 'string' }
                        },
                        required: [ 'id', 'username', 'accessToken', 'accessTokenSecret' ]
                    }
                },
                facebook: {
                    type: 'object',
                    schema: {
                        properties: {
                            id: { type: 'string' },
                            username: { type: 'string' },
                            accessToken: { type: 'string' }
                        },
                        required: [ 'id', 'username', 'accessToken' ]
                    }
                }
            }
        },
        autoGenerated: {
            createdAt: { event: 'created' },
            updatedAt: { event: 'updated' }
        },
        indexes: [
            { 'type': 1, 'email': 1 },
        ],
        links: {
            users: { type: 'user', field: 'credentialId' }
        },
        validate: function*(fields) {
            if (this.email && !emailRegex.test(this.email))
                return ['Invalid email'];
            return;
        }
    };



    /*
        Create a credential token.
        This can be used to upgrade to a user token, which is then used for login.
    */
    Credential.prototype.createSession = function*() {
        var session = new models.Session({
            credentialId: services.get('db').getRowId(this),
            token: randomizer.uniqueId(24)
        });
        return yield* session.save();
    };


    Credential.prototype.addBuiltin = function*(username, password) {
        var existing = yield* Credential.findOne({ "builtin.username": username }, services.copy());
        if (!existing) {
            var hashed = yield* thunkify(hasher)({ plaintext: password });
            this.builtin = {
                method: 'PBKDF2',
                username: username,
                salt: hashed.salt.toString('hex'),
                hash: hashed.key.toString('hex')
            };
            return yield* this.save(services.copy());
        } else {
            throw new Error("Built-in credential with the same username already exists");
        }
    };


    Credential.prototype.addTwitter = function*(id, username, accessToken, accessTokenSecret) {
        var existing = yield* Credential.findOne({ "twitter.id": id }, services.copy());
        if (!existing) {
            this.twitter = {
                id: id,
                username: username,
                accessToken: accessToken,
                accessTokenSecret: accessTokenSecret
            };
            return yield* this.save(services.copy());
        } else {
            throw new Error("Twitter credential with the same id already exists");
        }
    };


    Credential.authenticateBuiltin = function*(username, password) {
        var credential = yield* Credential.findOne({ "builtin.username": username }, services.copy());
        if (credential) {
            var salt = new Buffer(credential.builtin.salt, 'hex');
            result = yield* thunkify(hasher)({plaintext: password, salt: salt});
            return credential.hash === result.key.toString('hex') ?
                { token: credential.token } : { success: false, error: "Invalid username or password" };
        } else {
            return { success: false, error: "Invalid username or password" };
        }
    };


    exports.Credential = Credential;

})();
