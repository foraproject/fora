###
    A safe wrapper around the request to hide access to query, params and body.
    This allows us to sanitize those fields when requested.    
###

utils = require '../utils'
validator = require 'validator'
sanitizer = require 'sanitizer'
co = require 'co'
body = require 'co-body'
multipart = require 'co-multipart'

class RequestParser

    constructor: (@ctx, @typeUtils) ->


    
    init: ->*
        if not initted
            @rawBody = yield body @ctx
            initted = true            
    
    
    
    body: (name, def = 'string') =>
        if typeof def is 'string'
            def = @typeUtils.getFieldDefinition def
        @parsePrimitive @rawBody[name], def, name 
        

    
    files: =>*
        (yield* multipart @ctx).files
            


    map: (target, whitelist, options = { overwrite: true }, prefix = []) =>
        @init()
        typeDef = target.getTypeDefinition()     
        for field, def of typeDef.fields
            if @populateObject(target, field, def, whitelist, options, prefix) is true
                modified = true
        modified
   
        
    
    populateObject: (obj, name, def, whitelist, options, prefix) =>
        if not obj[name] or options.overwrite
            if name isnt '_id' and def.map isnt false and not def.autoGenerated
                fullName = prefix.concat(name).join '_'
                if @typeUtils.isPrimitiveType(def.type)
                    if whitelist.indexOf(fullName) > -1
                        val = @body fullName, 'string'
                        if val
                            obj[name] = @parsePrimitive val, def, fullName
                            return true            
                        else
                            if def.map isnt false and def.default
                                obj[name] = if typeof def.map.default is "function" then def.map.default(obj) else def.map.default
                                return true
                else
                    if def.type isnt ''
                        prefix.push name
                        
                        newObj = new def.ctor()
                        hasMapped = @map(newObj, whitelist, options, prefix)
                        if hasMapped
                            obj[name] = newObj
                            
                        prefix.pop()
                        
                        return hasMapped



    parsePrimitive: (val, def, fieldName) =>
        if val
            switch def.type
                when 'number'
                    (if def.integer then parseInt else parseFloat) val
                when 'string'
                    if def.allowHtml
                        sanitizer.sanitize(sanitizer.unescapeEntities val)
                    else
                        sanitizer.escape(val)
                when 'boolean'
                    val is "true"
                when 'array'
                    if def.map?.format is 'csv'
                        (@parsePrimitive(v, def.contents, fieldName) for v in val.split(','))                    
                    else
                        throw new Error "Cannot parse this array. Unknown format."
                else      
                    throw new Error "#{def.type} #{fieldName} is a non-primitive. Cannot parse."

exports.RequestParser = RequestParser
